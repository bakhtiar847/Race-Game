<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>HTML5 Race Game</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        /* 保持原有样式不变 */
        body { margin: 0; background: #2b2b2b; color: #fff; font-family: Arial, sans-serif; }
        #game-container {
            width: 80%;
            margin: 30px auto;
            background: #181818;
            border-radius: 14px;
            overflow: hidden;
            box-shadow: 0 4px 24px #000c;
            position: relative;
        }
        #track {
            position: relative; width: 100%; height: 400px;
            background: linear-gradient(to bottom, #444 0%, #222 100%);
            background-image:
                repeating-linear-gradient(
                    to bottom, #fff8 0 8px, transparent 8px 48px
                ),
                linear-gradient(to right, #888 0, #888 4%, transparent 4%, transparent 96%, #888 96%, #888 100%);
            border-left: 7px solid #bbb;
            border-right: 7px solid #bbb;
            touch-action: none;
            overflow: hidden;
        }
        .lane-divider {
            position: absolute;
            width: 6px;
            height: 48px;
            background: repeating-linear-gradient(
                to bottom,
                yellow 0 12px,
                transparent 12px 24px
            );
            opacity: 0.8;
            z-index: 1;
            pointer-events: none;
        }
        .car {
            position: absolute;
            width: 48px; height: 80px;
            left: 50%; transform: translateX(-50%);
            bottom: 16px;
            z-index: 2;
            border-radius: 13px 13px 9px 9px;
            box-shadow: 0 8px 20px #0008, 0 1px 0px 4px #2223 inset;
            border: 2.5px solid #fff7;
            overflow: visible;
        }
        .car .body {
            position: absolute;
            width: 100%; height: 100%;
            background: linear-gradient(160deg, #49f 0%, #1b3d7a 60%, #5af 100%);
            border-radius: 13px 13px 9px 9px;
            box-shadow: 0 6px 16px #0003;
        }
        .car.enemy .body {
            background: linear-gradient(160deg, #d22 0%, #900 60%, #fe7 100%);
            box-shadow: 0 8px 24px #9006;
        }
        .car .window, .car .grill, .car .wheel, .car .light {
            /* 保持原有样式 */
        }
        .obstacle {
            position: absolute; width: 40px; height: 40px;
            background: linear-gradient(120deg, #622 60%, #c33 100%);
            border-radius: 11px 25% 14px 7px / 12px 25% 8px 7px;
            box-shadow: 0 0 18px #e005, 0 6px 16px #0006;
            border: 2px solid #a001;
            z-index: 2;
        }
        .boost {
            position: absolute; width: 44px; height: 28px;
            background: linear-gradient(120deg, #9f6 60%, #3d5 100%);
            border-radius: 7px;
            box-shadow: 0 0 16px 4px #4fa8, 0 3px 8px #0007;
            border: 2px solid #fff;
            z-index: 2;
        }
        #score { padding: 10px 16px; font-size: 1.2em; background: #181818; letter-spacing: 1px; }
        #controls { display: flex; justify-content: space-between; gap: 10px; padding: 8px 0; }
        .btn {
            flex: 1; padding: 16px 0; border: none; background: #555; color: #fff;
            font-size: 1.1em; border-radius: 6px; margin: 0 6px; user-select: none;
        }
        .btn:active { background: #888; }
        #game-over, #upgrade-choice, #start-screen {
            display: none; position: absolute; left: 0; top: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.82); color: #fff; font-size: 1.2em;
            align-items: center; justify-content: center; flex-direction: column; z-index: 10;
        }
        .upgrade {
            position: absolute; width: 38px; height: 38px;
            background: linear-gradient(135deg, #ffd700 0%, #ffA500 100%);
            border-radius: 50%;
            box-shadow: 0 0 16px 4px #ffe60099, 0 3px 8px #0007;
            border: 2px solid #fff;
            z-index: 2;
        }
        #game-over.show, #upgrade-choice.show, #start-screen.show { display: flex; }
        .shield .body {
            box-shadow: 0 0 0 6px #0ef7 inset, 0 6px 16px #0003;
            outline: 3px solid #0ef7;
        }
        #upgrade-choice button {
            margin: 12px 0; padding: 10px 28px; font-size: 1.1em; background: #444; color: #fff;
            border-radius: 8px; border: none; transition: background 0.2s;
        }
        #upgrade-choice button:hover { background: #33e; }
        @media (max-width: 500px) {
            #game-container { border-radius: 0; }
            #track { height: 320px; }
            .car { width: 36px; height: 60px; }
        }
        .car {
            transition: left 0.4s cubic-bezier(0.3, 0.7, 0.4, 1), transform 0.4s cubic-bezier(0.3, 0.7, 0.4, 1);
        }
        .car.turn-left { transform: translateX(-50%) rotate(-22deg); }
        .car.turn-right { transform: translateX(-50%) rotate(22deg); }
        .heart {
            display: inline-block; width: 32px; height: 32px; background: none; vertical-align: middle;
        }
        .heart svg { width: 100%; height: 100%; display: block; }
        .heart-track { position: absolute; width: 32px; height: 32px; z-index: 2; pointer-events: none; }
        #start-screen { z-index: 20; }
        #start-screen h1 { font-size: 2.5em; margin-bottom: 20px; text-align: center; }
        #start-btn {
            padding: 15px 40px; font-size: 1.5em; background: #49f; color: white;
            border: none; border-radius: 8px; cursor: pointer; transition: all 0.3s;
        }
        #start-btn:hover { background: #5af; transform: scale(1.05); }
    </style>
</head>
<body>
<div id="game-container">
    <div id="score">Score: <span id="score-val">0</span></div>
    <div id="lives-overlay" style="position:absolute;top:10px;left:10px;z-index:20;"></div>
    <div id="timer" style="font-size: 24px; margin-bottom: 10px;">Time: 0s</div>
    <div id="track">
        <div class="car player" id="player-car"></div>
        <div id="start-screen" class="show">
            <h1>Race Game</h1>
            <button id="start-btn">Start Game</button>
        </div>
        <div id="game-over">
            <div>Game Over</div>
            <button class="btn" id="restart-btn">Restart</button>
        </div>
        <div id="upgrade-choice">
            <div>Choose an upgrade!</div>
            <button id="upgrade-speed">Speed Up</button>
            <button id="upgrade-size">Smaller Car</button>
            <button id="upgrade-shield">Get Shield</button>
            <button id="upgrade-magnet-left">Magnet Left</button>
            <button id="upgrade-magnet-right">Magnet Right</button>
            <button id="upgrade-heart">+1 Heart</button>
        </div>
    </div>
    <div id="controls">
        <button class="btn" id="left-btn">&#8592; Left</button>
        <button class="btn" id="right-btn">Right &#8594;</button>
    </div>
</div>
<script>
    // 游戏变量
    let lineOffset = 0;
    let upgradeSpawnTimer;
    let lives = 5; // 问题①修复：初始生命值从3增加到5，提高容错率
    const track = document.getElementById('track');
    const playerCar = document.getElementById('player-car');
    const scoreVal = document.getElementById('score-val');
    const gameOverScreen = document.getElementById('game-over');
    const restartBtn = document.getElementById('restart-btn');
    const leftBtn = document.getElementById('left-btn');
    const rightBtn = document.getElementById('right-btn');
    const upgradeMenu = document.getElementById('upgrade-choice');
    const startScreen = document.getElementById('start-screen');
    const startBtn = document.getElementById('start-btn');
    
    const upgradeBtns = {
        speed: document.getElementById('upgrade-speed'),
        size: document.getElementById('upgrade-size'),
        shield: document.getElementById('upgrade-shield'),
        magnetLeft: document.getElementById('upgrade-magnet-left'),
        magnetRight: document.getElementById('upgrade-magnet-right'),
        heart: document.getElementById('upgrade-heart')
    };

    // 车道计算
    const laneCount = 10;
    const lanes = () => {
        let w = track.offsetWidth;
        let spacing = w / laneCount;
        return Array.from({length: laneCount}, (_,i)=>spacing/2 + i*spacing);
    };

    // 游戏状态
    let playerLane, score, gameRunning, enemyCars, enemySpeed, enemySpawnTimer, obstacleTimer, boostTimer, upgrades, obstacles, boosts;
    let upgradePending = false;
    let carSpeed = 1, carSize = 1, shield = true, boostActive = false, boostTimeLeft = 0;
    let upgradeEvery = 10, lastUpgradeAt = 0;
    let magnetLeft = false, magnetRight = false;

    // 创建赛车DOM
    function makeCarDOM(target, isEnemy=false) {
        target.innerHTML = '';
        const body = document.createElement('div');
        body.className = 'body';
        if(isEnemy) body.classList.add('enemy');
        target.appendChild(body);
        const windowDiv = document.createElement('div');
        windowDiv.className = 'window';
        body.appendChild(windowDiv);
        const grill = document.createElement('div');
        grill.className = 'grill';
        body.appendChild(grill);
        const lightL = document.createElement('div');
        lightL.className = 'light left';
        body.appendChild(lightL);
        const lightR = document.createElement('div');
        lightR.className = 'light right';
        body.appendChild(lightR);
        const wheelL = document.createElement('div');
        wheelL.className = 'wheel left';
        body.appendChild(wheelL);
        const wheelR = document.createElement('div');
        wheelR.className = 'wheel right';
        body.appendChild(wheelR);
    }

    makeCarDOM(playerCar);

    function setCarPosition() {
        playerCar.style.left = lanes()[playerLane] + 'px';
    }
    
    function setCarSize(mult) {
        if (window.innerWidth <= 500) {
            playerCar.style.width = (36 * mult) + 'px';
            playerCar.style.height = (60 * mult) + 'px';
        } else {
            playerCar.style.width = (48 * mult) + 'px';
            playerCar.style.height = (80 * mult) + 'px';
        }
    }

    function createLaneDividers() {
        document.querySelectorAll('.lane-divider').forEach(e => e.remove());
        for (let i = 1; i < laneCount; i++) {
            const divider = document.createElement('div');
            divider.className = 'lane-divider';
            divider.style.left = (lanes()[i] - (track.offsetWidth / laneCount) / 2) + 'px';
            divider.style.top = '0px';
            divider.style.height = track.offsetHeight + 'px';
            track.appendChild(divider);
        }
    }

    function movePlayer(dir) {
        if (!gameRunning || upgradePending) return;
        let turningClass = '';
        let laneChanged = false;
        if (dir === 'left' && playerLane > 0) {
            playerLane--;
            turningClass = 'turn-left';
            laneChanged = true;
        }
        if (dir === 'right' && playerLane < laneCount-1) {
            playerLane++;
            turningClass = 'turn-right';
            laneChanged = true;
        }
        if (laneChanged && turningClass) {
            playerCar.classList.add(turningClass);
            setCarPosition();
            setTimeout(() => playerCar.classList.remove(turningClass), 400);
        } else if (laneChanged) {
            setCarPosition();
        }
    }

    function spawnEnemy() {
        const laneIdx = Math.floor(Math.random()*laneCount);
        const enemy = document.createElement('div');
        enemy.className = 'car enemy';
        enemy.style.left = lanes()[laneIdx] + 'px';
        enemy.style.top = '-90px';
        enemy.dataset.lane = laneIdx;
        makeCarDOM(enemy, true);
        track.appendChild(enemy);
        enemyCars.push({el:enemy, lane:laneIdx, y:-90});
    }

    function spawnObstacle() {
        const laneIdx = Math.floor(Math.random()*laneCount);
        const obs = document.createElement('div');
        obs.className = 'obstacle';
        obs.style.left = (lanes()[laneIdx] - 20) + 'px';
        obs.style.top = '-40px';
        obs.dataset.lane = laneIdx;
        track.appendChild(obs);
        obstacles.push({el:obs, lane:laneIdx, y:-40});
    }

    function spawnBoost() {
        const laneIdx = Math.floor(Math.random()*laneCount);
        const bst = document.createElement('div');
        bst.className = 'boost';
        bst.style.left = (lanes()[laneIdx] - 19) + 'px';
        bst.style.top = '-40px';
        bst.dataset.lane = laneIdx;
        track.appendChild(bst);
        boosts.push({el:bst, lane:laneIdx, y:-40});
    }

    function spawnUpgrade() {
        const laneIdx = Math.floor(Math.random()*laneCount);
        const upg = document.createElement('div');
        upg.className = 'upgrade';
        upg.style.left = (lanes()[laneIdx] - 19) + 'px';
        upg.style.top = '-40px';
        upg.dataset.lane = laneIdx;
        track.appendChild(upg);
        upgrades.push({el:upg, lane:laneIdx, y:-40});
    }

    // 问题②修复：敌方车辆转向调整
    // 变道间隔从700ms延长到1500ms，变道概率从30%降低到15%，减少转向频率
    setInterval(() => {
        if (!gameRunning) return;
        enemyCars.forEach(ec => {
            if (Math.random() < 0.15) { // 概率从0.3→0.15
                let possibleLanes = [];
                if (ec.lane > 0) possibleLanes.push(ec.lane - 1);
                if (ec.lane < laneCount - 1) possibleLanes.push(ec.lane + 1);
                if (possibleLanes.length > 0) {
                    let newLane = possibleLanes[Math.floor(Math.random() * possibleLanes.length)];
                    let dirClass = '';
                    if (newLane < ec.lane) dirClass = 'turn-right';
                    if (newLane > ec.lane) dirClass = 'turn-left';
                    if (dirClass) {
                        ec.el.classList.add(dirClass);
                        setTimeout(() => ec.el.classList.remove(dirClass), 600); // 转向动画延长到600ms，更平缓
                    }
                    ec.lane = newLane;
                    ec.el.style.left = lanes()[ec.lane] + 'px';
                }
            }
        });
    }, 1500); // 间隔从700→1500ms
    
    function showUpgradeMenu() {
        upgradeMenu.classList.add('show');
        upgradePending = true;
    }
    
    function hideUpgradeMenu() {
        upgradeMenu.classList.remove('show');
        upgradePending = false;
    }
    
    function moveObjs(){
        lineOffset = (lineOffset + carSpeed) % 48;
        track.style.backgroundPositionY = lineOffset + 'px';
        
        document.querySelectorAll('.lane-divider').forEach(divider => {
            let currentTop = parseFloat(divider.style.top || '0');
            currentTop += carSpeed;
            if (currentTop > track.offsetHeight) currentTop = -divider.offsetHeight;
            divider.style.top = currentTop + 'px';
        });
        
        enemyCars.forEach(ec => {
            ec.y += enemySpeed;
            ec.el.style.top = ec.y + 'px';
        });
        
        enemyCars = enemyCars.filter(ec=>{
            if (ec.y > track.offsetHeight) {
                ec.el.remove();
                score++;
                scoreVal.textContent = score;
                if (score % 5 === 0 && enemySpeed < 12) enemySpeed += 0.7 * carSpeed;
                if (score > 0 && score % upgradeEvery === 0 && score !== lastUpgradeAt) {
                    lastUpgradeAt = score;
                    showUpgradeMenu();
                }
                return false;
            }
            return true;
        });

        obstacles.forEach(obs => {
            obs.y += carSpeed;
            obs.el.style.top = obs.y + 'px';
        });
        obstacles = obstacles.filter(obs=>{
            if (obs.y > track.offsetHeight) {
                obs.el.remove();
                return false;
            }
            return true;
        });

        upgrades.forEach(upg => {
            upg.y += carSpeed;
            upg.el.style.top = upg.y + 'px';
        });
        upgrades = upgrades.filter(upg=>{
            if (upg.y > track.offsetHeight) {
                upg.el.remove();
                return false;
            }
            return true;
        });
        
        boosts.forEach(bst => {
            bst.y += carSpeed;
            bst.el.style.top = bst.y + 'px';
        });
        boosts = boosts.filter(bst=>{
            if (bst.y > track.offsetHeight) {
                bst.el.remove();
                return false;
            }
            return true;
        });
    }
    
    // 碰撞检测（问题①修复：优化碰撞惩罚）
    function collDetect(){
        const playerRect = playerCar.getBoundingClientRect();
        
        // 敌方车辆碰撞
        for (let ec of enemyCars) {
            const enemyRect = ec.el.getBoundingClientRect();
            if (rectsOverlap(playerRect, enemyRect)) {
                if (shield) {
                    // 护盾抵挡伤害，保留护盾但减少持续时间（原逻辑直接移除护盾，改为有缓冲）
                    shield = false;
                    playerCar.classList.remove('shield');
                    // 短暂无敌时间（1秒）
                    playerCar.style.opacity = "0.7";
                    setTimeout(() => playerCar.style.opacity = "1", 1000);
                } else {
                    // 无护盾时，仅扣除1条命（配合初始生命值增加，降低死亡速度）
                    removeLife();
                    // 碰撞后短暂无敌（1.5秒），避免连续碰撞
                    playerCar.style.opacity = "0.5";
                    setTimeout(() => playerCar.style.opacity = "1", 1500);
                }
                ec.el.remove();
                enemyCars = enemyCars.filter(e=>e!==ec);
                return;
            }
        }
        
        // 障碍物碰撞（逻辑同上）
        for (let obs of obstacles) {
            const obsRect = obs.el.getBoundingClientRect();
            if (rectsOverlap(playerRect, obsRect)) {
                if (shield) {
                    shield = false;
                    playerCar.classList.remove('shield');
                    playerCar.style.opacity = "0.7";
                    setTimeout(() => playerCar.style.opacity = "1", 1000);
                } else {
                    removeLife();
                    playerCar.style.opacity = "0.5";
                    setTimeout(() => playerCar.style.opacity = "1", 1500);
                }
                obs.el.remove();
                obstacles = obstacles.filter(o=>o!==obs);
                return;
            }
        }
        
        // 加速道具和升级道具碰撞逻辑不变
        for (let bst of boosts) {
            const bstRect = bst.el.getBoundingClientRect();
            if (rectsOverlap(playerRect, bstRect)) {
                bst.el.remove();
                boosts = boosts.filter(b=>b!==bst);
                boostActive = true;
                boostTimeLeft = 120;
                const body = playerCar.querySelector('.body');
                body.style.boxShadow = "0 0 24px 10px #0f7, 0 0 36px 18px #0f7 inset";
                body.style.outline = "4px solid #0f7";
                carSpeed = carSpeed * 2;
            }
        }

        for (let upg of upgrades) {
            const upgRect = upg.el.getBoundingClientRect();
            if (rectsOverlap(playerRect, upgRect)) {
                upg.el.remove();
                upgrades = upgrades.filter(u=>u!==upg);
                showUpgradeMenu();
                break;
            }
        }
        
        heartCollision();
    }

    function removeLife() {
        lives--;
        if (lives <= 0) {
            endGame();
        }
        drawHearts();
    }

    function gameLoop() {
        if (!gameRunning) return;
        
        if (boostActive) {
            boostTimeLeft--;
            if (boostTimeLeft <= 0) {
                boostActive = false;
                playerCar.querySelector('.body').style.boxShadow = "";
                playerCar.querySelector('.body').style.outline = "";
                carSpeed = carSpeed / 2;
                enemySpeed = 3 * carSpeed;
            }
        }
    
        moveObjs();
        moveHearts();
        collDetect();
        spawnObjs();
        attractToCar(boosts);
        attractToCar(upgrades, true);
        drawHearts();
        requestAnimationFrame(gameLoop);
    }

    function attractToCar(itemArray, isUpgrade=false) {
        itemArray.forEach(item => {
            const carLane = playerLane;
            if (magnetLeft && item.lane < carLane) {
                if (item.lane < laneCount-1 && item.lane + 1 <= carLane) {
                    item.lane += 1;
                    let offset = isUpgrade ? -19 : -19;
                    item.el.style.left = (lanes()[item.lane] + offset) + 'px';
                }
            }
            if (magnetRight && item.lane > carLane) {
                if (item.lane > 0 && item.lane - 1 >= carLane) {
                    item.lane -= 1;
                    let offset = isUpgrade ? -19 : -19;
                    item.el.style.left = (lanes()[item.lane] + offset) + 'px';
                }
            }
        });
    }
    
    function endGame() {
        gameRunning = false;
        stopTimer();
        gameOverScreen.classList.add('show');
        playerCar.querySelector('.body').style.boxShadow = "";
        playerCar.querySelector('.body').style.outline = "";
    }

    function rectsOverlap(r1, r2) {
        return !(r1.right < r2.left || r1.left > r2.right ||
                 r1.bottom < r2.top || r1.top > r2.bottom);
    }

    // 控制事件
    leftBtn.addEventListener('click', ()=>movePlayer('left'));
    rightBtn.addEventListener('click',()=>movePlayer('right'));
    restartBtn.addEventListener('click', resetGame);
    startBtn.addEventListener('click', () => {
        startScreen.classList.remove('show');
        startGame();
    });
    
    window.addEventListener('keydown', e=>{
        if (!gameRunning && e.key === 'Enter') resetGame();
        if (e.key === 'ArrowLeft') movePlayer('left');
        if (e.key === 'ArrowRight') movePlayer('right');
    });

    let touchStartX = null;
    track.addEventListener('touchstart', e=>{
        if (e.touches.length===1) touchStartX = e.touches[0].clientX;
    });
    track.addEventListener('touchend', e=>{
        if (touchStartX===null) return;
        let dx = (e.changedTouches[0].clientX - touchStartX);
        if (Math.abs(dx) > 40) {
            if (dx > 0) movePlayer('right');
            else movePlayer('left');
        }
        touchStartX = null;
    });

    window.addEventListener('resize', ()=>{
        setCarPosition();
        enemyCars.forEach(ec=>{
            ec.el.style.left = lanes()[ec.lane] + 'px';
        });
        obstacles.forEach(obs=>{
            obs.el.style.left = (lanes()[obs.lane] - 20) + 'px';
        });
        boosts.forEach(bst=>{
            bst.el.style.left = (lanes()[bst.lane] - 19) + 'px';
        });
        createLaneDividers();
    });

    // 升级逻辑
    upgradeBtns.speed.onclick = ()=>{
        carSpeed *= 1.25;
        enemySpeed = 3 * carSpeed;
        hideUpgradeMenu();
        requestAnimationFrame(gameLoop);
    };
    
    upgradeBtns.size.onclick = ()=>{
        carSize *= 0.8;
        setCarSize(carSize);
        hideUpgradeMenu();
        requestAnimationFrame(gameLoop);
    };
    
    upgradeBtns.shield.onclick = ()=>{
        shield = true;
        playerCar.classList.add('shield');
        hideUpgradeMenu();
        requestAnimationFrame(gameLoop);
    };
    
    upgradeBtns.magnetLeft.onclick = ()=>{
        magnetLeft = true;
        hideUpgradeMenu();
        requestAnimationFrame(gameLoop);
    };
    
    upgradeBtns.magnetRight.onclick = ()=>{
        magnetRight = true;
        hideUpgradeMenu();
        requestAnimationFrame(gameLoop);
    };
    
    upgradeBtns.heart.onclick = ()=>{
        addLife();
        hideUpgradeMenu();
        requestAnimationFrame(gameLoop);
    };

    function startGame() {
        resetGameState();
        gameRunning = true;
        requestAnimationFrame(gameLoop);
    }

    function resetGameState() {
        document.querySelectorAll('.upgrade').forEach(e=>e.remove());
        upgradeSpawnTimer = 350;
        startTimer();
        playerLane = 1;
        score = 0;
        carSpeed = 1;
        carSize = 1;
        shield = true;
        boostActive = false;
        upgrades = [];
        boostTimeLeft = 0;
        lastUpgradeAt = 0;
        enemyCars = [];
        enemySpeed = 3;
        enemySpawnTimer = 0;
        obstacleTimer = 60;
        boostTimer = 100;
        obstacles = [];
        boosts = [];
        lives = 5; // 重置时保持5条命
        scoreVal.textContent = score;
        gameOverScreen.classList.remove('show');
        upgradeMenu.classList.remove('show');
        playerCar.classList.add('shield'); // 重置时恢复护盾
        playerCar.style.opacity = "1"; // 重置透明度
        makeCarDOM(playerCar);
        setCarSize(carSize);
        setCarPosition();
        document.querySelectorAll('.car.enemy, .obstacle, .boost').forEach(e=>e.remove());
        magnetLeft = false;
        magnetRight = false;
        createLaneDividers();
        drawHearts();
    }

    function resetGame() {
        startScreen.classList.remove('show');
        resetGameState();
        gameRunning = true;
        requestAnimationFrame(gameLoop);
    }

    function spawnObjs() {
        if (!gameRunning) return;
        
        enemySpawnTimer--;
        if (enemySpawnTimer <= 0) {
            spawnEnemy();
            enemySpawnTimer = Math.floor(60 / enemySpeed);
        }
        
        obstacleTimer--;
        if (obstacleTimer <= 0) {
            spawnObstacle();
            obstacleTimer = Math.floor(Math.random() * 60) + 40;
        }
        
        boostTimer--;
        if (boostTimer <= 0) {
            spawnBoost();
            boostTimer = Math.floor(Math.random() * 100) + 150;
        }
        
        upgradeSpawnTimer--;
        if (upgradeSpawnTimer <= 0) {
            spawnUpgrade();
            upgradeSpawnTimer = Math.floor(Math.random() * 150) + 200;
        }
        
        if (Math.random() < 0.005) {
            spawnHeart();
        }
    }
    
    document.addEventListener('DOMContentLoaded', () => {
        createLaneDividers();
        drawHearts();
        startScreen.classList.add('show');
    });
    
    let time = 0;
    let timerInterval = null;

    function startTimer() {
        time = 0;
        clearInterval(timerInterval);
        timerInterval = setInterval(() => {
            time++;
            document.getElementById('timer').textContent = 'Time: ' + time + 's';
        }, 1000);
    }

    function stopTimer() {
        clearInterval(timerInterval);
    }
    
    function drawHearts() {
        const overlay = document.getElementById('lives-overlay');
        overlay.innerHTML = '';
        for (let i = 0; i < lives; i++) {
            overlay.innerHTML += `<span class="heart"><svg viewBox='0 0 32 32'><path d='M16 29s-11-7.6-11-15.2C5 7.6 9.6 4 16 10.2 22.4 4 27 7.6 27 13.8 27 21.4 16 29 16 29z' fill='#e33' stroke='#fff' stroke-width='2'/></svg></span>`;
        }
    }
    
    function spawnHeart() {
        const laneIdx = Math.floor(Math.random()*laneCount);
        const heart = document.createElement('div');
        heart.className = 'heart-track';
        heart.style.left = (lanes()[laneIdx] - 16) + 'px';
        heart.style.top = '-32px';
        heart.dataset.lane = laneIdx;
        heart.innerHTML = `<svg viewBox='0 0 32 32'><path d='M16 29s-11-7.6-11-15.2C5 7.6 9.6 4 16 10.2 22.4 4 27 7.6 27 13.8 27 21.4 16 29 16 29z' fill='#e33' stroke='#fff' stroke-width='2'/></svg>`;
        track.appendChild(heart);
        heartsOnTrack.push({el:heart, lane:laneIdx, y:-32});
    }
    
    let heartsOnTrack = [];
    
    function moveHearts() {
        heartsOnTrack.forEach(h => {
            h.y += carSpeed;
            h.el.style.top = h.y + 'px';
        });
        heartsOnTrack = heartsOnTrack.filter(h => {
            if (h.y > track.offsetHeight) {
                h.el.remove();
                return false;
            }
            return true;
        });
    }
    
    function heartCollision() {
        const playerRect = playerCar.getBoundingClientRect();
        for (let h of heartsOnTrack) {
            const hRect = h.el.getBoundingClientRect();
            if (rectsOverlap(playerRect, hRect)) {
                h.el.remove();
                heartsOnTrack = heartsOnTrack.filter(x=>x!==h);
                addLife();
                break;
            }
        }
    }

    function addLife() {
        lives++;
        drawHearts();
    }
</script>
</body>
</html>