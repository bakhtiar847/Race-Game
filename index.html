<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>HTML5 Race Game</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        /*
         * --- CSS Styling ---
         * This section styles the game layout, track, cars, obstacles, boosts, upgrades, hearts, and UI elements.
         * Each class or ID corresponds to a part of the game (track, car, buttons, overlays, etc).
         * Comments are added to explain the purpose of each block.
         */
        body { margin: 0; background: #2b2b2b; color: #fff; font-family: Arial, sans-serif; }
        #game-container {
            width: 80%;
            margin: 30px auto;
            background: #181818;
            border-radius: 14px;
            overflow: hidden;
            box-shadow: 0 4px 24px #000c;
        }
        #track {
            position: relative; width: 100%;
            height: 60vh; /* Responsive height: 60% of viewport height */
            min-height: 260px;
            max-height: 80vh;
            background: linear-gradient(to bottom, #444 0%, #222 100%);
            /* Lane lines (center and sides) */
            background-image:
                repeating-linear-gradient(
                    to bottom, #fff8 0 8px, transparent 8px 48px
                ),
                linear-gradient(to right, #888 0, #888 4%, transparent 4%, transparent 96%, #888 96%, #888 100%);
            border-left: 7px solid #bbb;
            border-right: 7px solid #bbb;
            touch-action: none;
            overflow: hidden;
            transition: height 0.3s;
        }
        .lane-marker {
            position: absolute;
            width: 6px;
            height: 36px;
            background: linear-gradient(to bottom, #fff, #ccc 60%, #aaa);
            left: 50%; transform: translateX(-50%);
            opacity: 0.7;
            z-index: 0;
        }
        .lane-divider {
    position: absolute;
    width: 6px;
    height: 48px;
    background: repeating-linear-gradient(
        to bottom,
        yellow 0 12px,
        transparent 12px 24px
    );
    opacity: 0.8;
    z-index: 1;
    pointer-events: none;
}
        /* Realistic Car Styling */
        .car {
            position: absolute;
            width: 48px; height: 80px;
            left: 50%; transform: translateX(-50%);
            bottom: 16px;
            z-index: 2;
            border-radius: 13px 13px 9px 9px;
            box-shadow: 0 8px 20px #0008, 0 1px 0px 4px #2223 inset;
            border: 2.5px solid #fff7;
            overflow: visible;
        }
        .car .body {
            position: absolute;
            width: 100%; height: 100%;
            background: linear-gradient(160deg, #49f 0%, #1b3d7a 60%, #5af 100%);
            border-radius: 13px 13px 9px 9px;
            box-shadow: 0 6px 16px #0003;
        }
        .car.enemy .body {
            background: linear-gradient(160deg, #d22 0%, #900 60%, #fe7 100%);
            box-shadow: 0 8px 24px #9006;
        }
        .car .window {
            position: absolute;
            left: 9px; top: 12px;
            width: 30px; height: 24px;
            background: linear-gradient(145deg, #e7f8ff 65%, #9ad6ff 100%);
            border-radius: 7px 7px 10px 10px;
            box-shadow: 0 0 8px #fff7;
            border: 1.5px solid #b0e1ff;
        }
        .car .grill {
            position: absolute;
            left: 14px; bottom: 7px;
            width: 20px; height: 8px;
            background: #222;
            border-radius: 6px 6px 10px 10px;
            box-shadow: 0 2px 6px #000a;
            border: 1px solid #666;
        }
        .car .wheel {
            position: absolute;
            width: 12px; height: 22px;
            background: linear-gradient(160deg, #232323 60%, #555 100%);
            border-radius: 7px;
            box-shadow: 0 2px 5px #000a;
            top: 59px;
        }
        .car .wheel.left { left: 2px; }
        .car .wheel.right { right: 2px; }
        .car .light {
            position: absolute;
            width: 7px; height: 8px;
            background: linear-gradient(120deg, #ffd 60%, #ffb 100%);
            border-radius: 2px 4px 7px 7px;
            top: 4px;
        }
        .car .light.left { left: 8px; }
        .car .light.right { right: 8px; }
        /* Enemy Car highlights */
        .car.enemy .light {
            background: linear-gradient(120deg, #fbb 60%, #f44 100%);
        }
        /* Obstacle Styling */
        .obstacle {
            position: absolute; width: 40px; height: 40px;
            background: linear-gradient(120deg, #622 60%, #c33 100%);
            border-radius: 11px 25% 14px 7px / 12px 25% 8px 7px;
            box-shadow: 0 0 18px #e005, 0 6px 16px #0006;
            border: 2px solid #a001;
            z-index: 2;
        }
        /* Boost Styling */
        .boost {
    position: absolute; width: 44px; height: 28px;
    background: linear-gradient(120deg, #9f6 60%, #3d5 100%);
    border-radius: 7px;
    box-shadow: 0 0 16px 4px #4fa8, 0 3px 8px #0007;
    border: 2px solid #fff;
    z-index: 2;
}
        #score {
            padding: 10px 16px; font-size: 1.2em;
            background: #181818; letter-spacing: 1px;
        }
        #controls {
            display: flex; justify-content: space-between; gap: 10px; padding: 8px 0;
        }
        .btn {
            flex: 1; padding: 16px 0; border: none; background: #555; color: #fff;
            font-size: 1.1em; border-radius: 6px; margin: 0 6px; user-select: none; touch-action: manipulation;
        }
        .btn:active { background: #888; }
        #game-over, #upgrade-choice {
            display: none; position: absolute; left: 0; top: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.82); color: #fff; font-size: 1.2em;
            align-items: center; justify-content: center; flex-direction: column; z-index: 10;
        }
        #upgrade-choice {
            overflow-y: auto;
            max-height: 90%;
            scrollbar-width: thin;
        }
        #upgrade-choice::-webkit-scrollbar {
            width: 8px;
            background: #222;
        }
        #upgrade-choice::-webkit-scrollbar-thumb {
            background: #444;
            border-radius: 6px;
        }
        .upgrade {
    position: absolute; width: 38px; height: 38px;
    background: radial-gradient(circle at 30% 30%, #ffe066 70%, #ffd700 100%, #bfa100 100%);
    border-radius: 50%;
    box-shadow: 0 0 16px 4px #ffe60099, 0 3px 8px #0007;
    border: 2px solid #fff7;
    z-index: 2;
    display: flex;
    align-items: center;
    justify-content: center;
    overflow: visible;
}
        #game-over.show, #upgrade-choice.show { display: flex; }
        .shield .body {
            box-shadow: 0 0 0 6px #0ef7 inset, 0 6px 16px #0003;
            outline: 3px solid #0ef7;
        }
        #upgrade-choice button {
            margin: 12px 0; padding: 10px 28px; font-size: 1.1em; background: #444; color: #fff; border-radius: 8px; border: none;
            transition: background 0.2s;
        }
        #upgrade-choice button:hover { background: #33e; }
        @media (max-width: 500px) {
            #game-container { border-radius: 0; }
            #track { height: 38vh; min-height: 160px; }
            .car { width: 36px; height: 60px; }
        }
       .car {
    transition: left 0.4s cubic-bezier(0.3, 0.7, 0.4, 1), transform 0.4s cubic-bezier(0.3, 0.7, 0.4, 1);
}
        .car.turn-left {
    transform: translateX(-50%) rotate(-22deg);
}
.car.turn-right {
    transform: translateX(-50%) rotate(22deg);
}
/* Heart (life) Styling */
        .heart {
            display: inline-block;
            width: 32px; height: 32px;
            background: none;
            vertical-align: middle;
        }
        .heart svg {
            width: 100%; height: 100%;
            display: block;
        }
        .heart-track {
            position: absolute; width: 32px; height: 32px;
            z-index: 2;
            pointer-events: none;
        }
    </style>
</head>
<body>
<!--
        --- Controls Pop-up ---
        This overlay lists all game controls and can be closed by the user.
-->
<div id="controls-popup" style="display:none; position:fixed; left:0; top:0; right:0; bottom:0; background:rgba(0,0,0,0.88); color:#fff; z-index:1000; align-items:center; justify-content:center; flex-direction:column; font-size:1.15em;">
    <div style="background:#222; border-radius:12px; padding:32px 28px; max-width:95vw; width:350px; box-shadow:0 8px 32px #000b; display:flex; flex-direction:column; align-items:center;">
        <h2 style="margin-top:0;">Game Controls</h2>
        <ul style="text-align:left; margin-bottom:18px;">
            <li><b>← / →</b> — Move Left / Right</li>
            <li><b>↑</b> — Accelerate</li>
            <li><b>↓</b> — Brake</li>
            <li><b>Space</b> — Pause / Resume</li>
            <li><b>P</b> — Parking Brake</li>
            <li><b>B</b> — Parking Brake (alt)</li>
            <li><b>E</b> — Toggle Engine</li>
            <li><b>U</b> — Open Upgrade Menu</li>
            <li><b>1-6</b> — Use Upgrades (if coins)</li>
            <li><b>Mouse/Touch</b> — On-screen buttons & swipe</li>
        </ul>
        <button id="close-controls-popup" class="btn" style="margin-top:8px;">Close</button>
    </div>
</div>
<div id="game-container">
    <!-- Score display -->
    <div id="score">Score: <span id="score-val">0</span> | Coins: <span id="coin-val">0</span>
    <button id="open-shop-btn" class="btn" style="margin-left:16px; padding:4px 18px; font-size:1em;">Open Shop</button>
    <button id="pause-btn" class="btn" style="margin-left:8px; padding:4px 18px; font-size:1em;">Pause</button>
    <button id="controls-btn" class="btn" style="margin-left:8px; padding:4px 18px; font-size:1em;">Controls</button>
    </div>
    <!-- Hearts (lives) overlay -->
    <div id="lives-overlay" style="position:absolute;top:10px;left:10px;z-index:20;"></div>
    <!-- Timer display -->
    <div id="timer" style="font-size: 24px; margin-bottom: 10px;">Time: 0s</div>
    <!--
        --- Track ---
        This is the main play area. Cars, obstacles, boosts, upgrades, and hearts appear here.
    -->
    <div id="track">
        <!-- Player's car -->
        <div class="car player" id="player-car"></div>
        <!-- Game Over overlay -->
        <div id="game-over">
            <div>Game Over</div>
            <button class="btn" id="restart-btn">Restart</button>
        </div>
        <!-- Upgrade choice menu -->
        <div id="upgrade-choice">
            <div>Choose an upgrade!</div>
            <button id="upgrade-speed">Speed Up</button>
            <button id="upgrade-size">Smaller Car</button>
            <button id="upgrade-shield">Get Shield</button>
            <button id="upgrade-magnet-left">Magnet Left</button>
            <button id="upgrade-magnet-right">Magnet Right</button>
            <button id="upgrade-heart">+1 Heart</button>
            <button id="close-shop-btn">Close</button>
        </div>
    </div>
    <!-- Controls for left/right movement (for mobile and desktop) -->
    <div id="controls">
        <button class="btn" id="engine-btn">Stop Engine</button>
        <button class="btn" id="park-btn">Parking Brake</button>
        <button class="btn" id="brake-btn">&#8595; Brake</button>
        <button class="btn" id="left-btn">&#8592; Left</button>
        <button class="btn" id="right-btn">Right &#8594;</button>
        <button class="btn" id="accel-btn">&#8593; Accelerate</button>
    </div>
</div>
<!-- Main game logic is below. All game code is in this script tag. -->
<script>
    // =============================
    //      CONTROLS POPUP LOGIC
    // =============================
    const controlsPopup = document.getElementById('controls-popup');
    const controlsBtn = document.getElementById('controls-btn');
    const closeControlsPopup = document.getElementById('close-controls-popup');
    controlsBtn.addEventListener('click', () => {
        controlsPopup.style.display = 'flex';
    });
    closeControlsPopup.addEventListener('click', () => {
        controlsPopup.style.display = 'none';
    });
    // Optional: ESC key closes controls popup
    window.addEventListener('keydown', e => {
        if (controlsPopup.style.display === 'flex' && (e.key === 'Escape' || e.key === 'Esc')) {
            controlsPopup.style.display = 'none';
        }
    });
    // =============================
    //      RESTART BUTTON HANDLER
    // =============================
    // Make the restart button refresh the page
    document.getElementById('restart-btn').onclick = function() {
        window.location.reload();
    };
    // =============================
    //      HELPER FUNCTIONS
    // =============================
    // Check if two rectangles overlap (collision detection)
    function rectsOverlap(r1, r2) {
        return !(
            r1.right < r2.left ||
            r1.left > r2.right ||
            r1.bottom < r2.top ||
            r1.top > r2.bottom
        );
    }

    // Spawn objects (enemies, obstacles, boosts, upgrades, hearts) at intervals
    function spawnObjs() {
        // --- Density adjustment based on track height ---
        const referenceHeight = 400; // px, original track height
        const currentHeight = track.offsetHeight || referenceHeight;
        const densityFactor = currentHeight / referenceHeight;
        // To keep density consistent, divide spawn timers by densityFactor
        // (i.e., spawn more frequently on larger tracks)

        // Enemy car spawn
        if (!enemySpawnTimer || enemySpawnTimer <= 0) {
            spawnEnemy();
            enemySpawnTimer = Math.max(10, Math.round((60 - Math.floor(score / 2)) / densityFactor));
        } else {
            enemySpawnTimer--;
        }
        // Obstacle spawn
        if (!obstacleTimer || obstacleTimer <= 0) {
            if (Math.random() < 0.5) spawnObstacle();
            obstacleTimer = Math.max(10, Math.round((80 + Math.random() * 40) / densityFactor));
        } else {
            obstacleTimer--;
        }
        // Boost spawn
        if (!boostTimer || boostTimer <= 0) {
            if (Math.random() < 0.3) spawnBoost();
            boostTimer = Math.max(10, Math.round((180 + Math.random() * 60) / densityFactor));
        } else {
            boostTimer--;
        }
        // Upgrade spawn
        if (!upgradeSpawnTimer || upgradeSpawnTimer <= 0) {
            if (Math.random() < 0.2) spawnUpgrade();
            upgradeSpawnTimer = Math.max(10, Math.round((350 + Math.random() * 100) / densityFactor));
        } else {
            upgradeSpawnTimer--;
        }
        // Heart spawn
        if (Math.random() < 0.003 / densityFactor) spawnHeart();
    }

    // Attract objects to the player's car if magnet is active
    function attractToCar(arr, isUpgrade = false) {
        if ((!magnetLeft && !magnetRight) && !isUpgrade) return;
        arr.forEach(obj => {
            // Only attract if in adjacent lane
            if (Math.abs(obj.lane - playerLane) === 1) {
                if ((magnetLeft && obj.lane < playerLane) || (magnetRight && obj.lane > playerLane) || isUpgrade) {
                    // Move object toward player lane
                    if (obj.lane < playerLane) obj.lane++;
                    else if (obj.lane > playerLane) obj.lane--;
                    obj.el.style.left = (lanes()[obj.lane] - (isUpgrade ? 19 : (obj.el.classList.contains('boost') ? 19 : 20))) + 'px';
                }
            }
        });
    }

    // End the game and show the game over screen
    function endGame() {
        gameRunning = false;
        stopTimer();
        gameOverScreen.classList.add('show');
    }

    // Update the coin display
    function updateCoins() {
        coinVal.textContent = coins;
    }
    // =============================
    //      GAME VARIABLES
    // =============================
    // These variables keep track of the game state, player, enemies, upgrades, etc.
    let lineOffset = 0;
    let upgradeSpawnTimer;
    let lives = 3;
    const track = document.getElementById('track');
    const playerCar = document.getElementById('player-car');
    const scoreVal = document.getElementById('score-val');
    const coinVal = document.getElementById('coin-val');
    const upgradeBtns = {
        speed: document.getElementById('upgrade-speed'),
        size: document.getElementById('upgrade-size'),
        shield: document.getElementById('upgrade-shield'),
        magnetLeft: document.getElementById('upgrade-magnet-left'),
        magnetRight: document.getElementById('upgrade-magnet-right'),
        heart: document.getElementById('upgrade-heart'),
        ghost: document.getElementById('upgrade-ghost'),
        close: document.getElementById('close-shop-btn')
    };

    // =============================
    //      GHOST UPGRADE
    // =============================
    let ghostActive = false;
    let ghostTimer = 0;
    function activateGhost() {
        if (ghostActive) return;
        ghostActive = true;
        ghostTimer = 30 * 60; // 30 seconds at 60fps
        playerCar.style.opacity = '0.5';
        playerCar.style.filter = 'drop-shadow(0 0 16px #fff)';
        // Optionally, add a blue glow
        playerCar.querySelector('.body').style.boxShadow = '0 0 32px 16px #0ff, 0 0 36px 18px #0ff7 inset';
    }
    // Ghost upgrade button logic
    if (upgradeBtns.ghost) {
        upgradeBtns.ghost.onclick = () => {
            activateGhost();
            coins = Math.max(0, coins - 1);
            updateCoins();
            if (coins === 0) hideUpgradeMenu();
        };
    }
    const openShopBtn = document.getElementById('open-shop-btn');
    const pauseBtn = document.getElementById('pause-btn');
    // Fix: define missing overlay elements
    const gameOverScreen = document.getElementById('game-over');
    const upgradeMenu = document.getElementById('upgrade-choice');
    let coins = 0;
    let shopOpen = false;
    let paused = false;

    // =============================
    //      LANE CALCULATION
    // =============================
    // Returns an array of x-positions for each lane, based on the track width and number of lanes.
    const laneCount = 10;
    const lanes = () => {
        let w = track.offsetWidth;
        let spacing = w / laneCount;
        return Array.from({length: laneCount}, (_,i)=>spacing/2 + i*spacing);
    };

    // =============================
    //      GAME STATE VARIABLES
    // =============================
    // These variables are used to keep track of the player, score, enemies, obstacles, upgrades, etc.
    let playerLane, score, gameRunning, enemyCars, enemySpeed, enemySpawnTimer, obstacleTimer, boostTimer, upgrades, obstacles, boosts;
    let upgradePending = false;
    let carSpeed = 1, carSize = 4, shield = true, boostActive = false, boostTimeLeft = 0;
    let maxSpeed = 6;
    let engineOn = true;
    let parkingBrake = false;
    let upgradeEvery = 10, lastUpgradeAt = 0;
    let magnetLeft = false, magnetRight = false;

    // =============================
    //      CAR VISUALS
    // =============================
    // This function creates the car's DOM structure (body, windows, grill, lights, wheels).
    function makeCarDOM(target, isEnemy=false) {
        target.innerHTML = '';
        const body = document.createElement('div');
        body.className = 'body';
        if(isEnemy) body.classList.add('enemy');
        target.appendChild(body);
        // Windows
        const windowDiv = document.createElement('div');
        windowDiv.className = 'window';
        body.appendChild(windowDiv);
        // Grill
        const grill = document.createElement('div');
        grill.className = 'grill';
        body.appendChild(grill);
        // Lights
        const lightL = document.createElement('div');
        lightL.className = 'light left';
        body.appendChild(lightL);
        const lightR = document.createElement('div');
        lightR.className = 'light right';
        body.appendChild(lightR);
        // Wheels
        const wheelL = document.createElement('div');
        wheelL.className = 'wheel left';
        body.appendChild(wheelL);
        const wheelR = document.createElement('div');
        wheelR.className = 'wheel right';
        body.appendChild(wheelR);
    }

    // Setup player car visuals
    // Call this once to create the player's car appearance.
    makeCarDOM(playerCar);

    // =============================
    //      PLAYER CAR POSITION
    // =============================
    // Set the player's car position based on the current lane.
    function setCarPosition() {
        playerCar.style.left = lanes()[playerLane] + 'px';
    }
    // Set the player's car size (used for upgrades).
    function setCarSize(mult) {
        if (window.innerWidth <= 500) {
            playerCar.style.width = (36 * mult) + 'px';
            playerCar.style.height = (60 * mult) + 'px';
        } else {
            playerCar.style.width = (48 * mult) + 'px';
            playerCar.style.height = (80 * mult) + 'px';
        }
    }

    // =============================
    //      LANE DIVIDERS
    // =============================
    // Draw vertical lane divider lines on the track.
    function createLaneDividers() {
    // Remove old dividers if any
    document.querySelectorAll('.lane-divider').forEach(e => e.remove());
    // Don't draw on first/last edge; just between lanes
    for (let i = 1; i < laneCount; i++) {
        const divider = document.createElement('div');
        divider.className = 'lane-divider';
        divider.style.left = (lanes()[i] - (track.offsetWidth / laneCount) / 2) + 'px'; // center divider between lanes
        divider.style.top = '0px';
        divider.style.height = track.offsetHeight + 'px';
        track.appendChild(divider);
    }
}

    // =============================
    //      PLAYER MOVEMENT
    // =============================
    // Move the player's car left or right by changing lanes.
    function movePlayer(dir) {
    if (!gameRunning || upgradePending) return;
    let turningClass = '';
    let laneChanged = false;
    if (dir === 'left' && playerLane > 0) {
        playerLane--;
        turningClass = 'turn-left';
        laneChanged = true;
    }
    if (dir === 'right' && playerLane < laneCount-1) {
        playerLane++;
        turningClass = 'turn-right';
        laneChanged = true;
    }
    if (laneChanged && turningClass) {
        playerCar.classList.add(turningClass);
        setCarPosition();
        setTimeout(() => playerCar.classList.remove(turningClass), 400); // Match transition time
    } else if (laneChanged) {
        setCarPosition();
    }
}

    // =============================
    //      SPAWN ENEMY CAR
    // =============================
    // Spawn an enemy car in a random lane at the top of the track.
    function spawnEnemy() {
        const laneIdx = Math.floor(Math.random()*laneCount);
        const enemy = document.createElement('div');
        enemy.className = 'car enemy';
        enemy.style.left = lanes()[laneIdx] + 'px';
        enemy.style.top = '-90px';
        enemy.dataset.lane = laneIdx;
        makeCarDOM(enemy, true);
        track.appendChild(enemy);
        enemyCars.push({el:enemy, lane:laneIdx, y:-90});
    }

    // =============================
    //      SPAWN OBSTACLE
    // =============================
    // Spawn an obstacle in a random lane at the top of the track.
    function spawnObstacle() {
        const laneIdx = Math.floor(Math.random()*laneCount);
        const obs = document.createElement('div');
        obs.className = 'obstacle';
        obs.style.left = (lanes()[laneIdx] - 20) + 'px';
        obs.style.top = '-40px';
        obs.dataset.lane = laneIdx;
        track.appendChild(obs);
        obstacles.push({el:obs, lane:laneIdx, y:-40});
    }

    // =============================
    //      SPAWN BOOST
    // =============================
    // Spawn a speed boost in a random lane at the top of the track.
    function spawnBoost() {
        const laneIdx = Math.floor(Math.random()*laneCount);
        const bst = document.createElement('div');
        bst.className = 'boost';
        bst.style.left = (lanes()[laneIdx] - 19) + 'px';
        bst.style.top = '-40px';
        bst.dataset.lane = laneIdx;
        track.appendChild(bst);
        boosts.push({el:bst, lane:laneIdx, y:-40});
    }

// =============================
//      SPAWN UPGRADE
// =============================
// Spawn an upgrade in a random lane at the top of the track.
function spawnUpgrade() {
    const laneIdx = Math.floor(Math.random()*laneCount);
    const upg = document.createElement('div');
    upg.className = 'upgrade';
    upg.style.left = (lanes()[laneIdx] - 19) + 'px';
    upg.style.top = '-40px';
    upg.dataset.lane = laneIdx;
    // Gold coin SVG
    upg.innerHTML = `<svg width="32" height="32" viewBox="0 0 32 32"><circle cx="16" cy="16" r="14" fill="#ffd700" stroke="#bfa100" stroke-width="3"/><circle cx="16" cy="16" r="9" fill="#fff8b0" opacity="0.5"/><text x="16" y="22" text-anchor="middle" font-size="16" font-family="Arial" fill="#bfa100" font-weight="bold">$</text></svg>`;
    track.appendChild(upg);
    upgrades.push({el:upg, lane:laneIdx, y:-40});
}

    // =============================
    //      ENEMY CAR MOVEMENT (AI) & OBSTACLE INTERACTION
    // =============================
    // Enhanced enemy car AI: random speed, parking, sideways driving, U-turns
    setInterval(() => {
        if (!gameRunning) return;
    enemyCars.forEach((ec, idx) => {
            // Initialize AI state if not present
            if (!ec.ai) {
                ec.ai = {
                    speed: enemySpeed * (0.7 + Math.random() * 1.2),
                    parked: false,
                    sideways: false,
                    uturn: false,
                    uturnProgress: 0,
                    parkTimer: 0,
                    sidewaysTimer: 0,
                    uturnTimer: 0,
                    speedChangeTimer: Math.floor(30 + Math.random() * 60),
                    stopped: false,
                    stopTimer: 0
                };
            }

            // --- Random speed change logic ---
            ec.ai.speedChangeTimer--;
            if (ec.ai.speedChangeTimer <= 0) {
                // 50% chance to change speed, 20% chance to stop
                if (Math.random() < 0.2 && !ec.ai.stopped && !ec.ai.parked && !ec.ai.uturn) {
                    ec.ai.stopped = true;
                    ec.ai.stopTimer = 20 + Math.floor(Math.random() * 40);
                    ec.el.style.opacity = '0.5';
                } else {
                    ec.ai.speed = enemySpeed * (0.6 + Math.random() * 1.5);
                }
                ec.ai.speedChangeTimer = Math.floor(30 + Math.random() * 60);
            }
            if (ec.ai.stopped) {
                ec.ai.stopTimer--;
                if (ec.ai.stopTimer <= 0) {
                    ec.ai.stopped = false;
                    ec.el.style.opacity = '';
                }
                return;
            }

            // --- U-Turn logic ---
            if (!ec.ai.uturn && Math.random() < 0.01) {
                ec.ai.uturn = true;
                ec.ai.uturnProgress = 0;
                ec.el.style.transition = 'transform 0.7s cubic-bezier(0.3,0.7,0.4,1)';
                ec.el.style.transform += ' rotate(180deg)';
            }
            if (ec.ai.uturn) {
                ec.ai.uturnProgress++;
                // Move up for half, then down for half
                if (ec.ai.uturnProgress < 20) {
                    ec.y -= ec.ai.speed * 1.2;
                } else if (ec.ai.uturnProgress < 40) {
                    ec.y += ec.ai.speed * 1.2;
                } else {
                    ec.ai.uturn = false;
                    ec.el.style.transform = ec.el.style.transform.replace(' rotate(180deg)', '');
                }
                return;
            }
            // --- Parking logic ---
            if (!ec.ai.parked && Math.random() < 0.02) {
                ec.ai.parked = true;
                ec.ai.parkTimer = 30 + Math.floor(Math.random() * 40);
                ec.el.style.opacity = '0.7';
            }
            if (ec.ai.parked) {
                ec.ai.parkTimer--;
                if (ec.ai.parkTimer <= 0) {
                    ec.ai.parked = false;
                    ec.el.style.opacity = '';
                }
                return;
            }
            // --- Sideways driving logic ---
            if (!ec.ai.sideways && Math.random() < 0.01) {
                ec.ai.sideways = true;
                ec.ai.sidewaysTimer = 20 + Math.floor(Math.random() * 30);
                ec.el.style.transition = 'transform 0.4s cubic-bezier(0.3,0.7,0.4,1)';
                ec.el.style.transform += ' rotate(90deg)';
            }
            if (ec.ai.sideways) {
                ec.ai.sidewaysTimer--;
                // Move sideways (left or right randomly)
                let dir = Math.random() < 0.5 ? -1 : 1;
                let newLane = ec.lane + dir;
                if (newLane >= 0 && newLane < laneCount) {
                    ec.lane = newLane;
                    ec.el.style.left = lanes()[ec.lane] + 'px';
                }
                if (ec.ai.sidewaysTimer <= 0) {
                    ec.ai.sideways = false;
                    ec.el.style.transform = ec.el.style.transform.replace(' rotate(90deg)', '');
                }
                return;
            }
            // --- Check for collision with obstacles ---
            let collided = false;
            for (let obs of obstacles) {
                const enemyRect = ec.el.getBoundingClientRect();
                const obsRect = obs.el.getBoundingClientRect();
                if (rectsOverlap(enemyRect, obsRect)) {
                    collided = true;
                    let possibleLanes = [];
                    if (ec.lane > 0) possibleLanes.push(ec.lane - 1);
                    if (ec.lane < laneCount - 1) possibleLanes.push(ec.lane + 1);
                    let moved = false;
                    for (let newLane of possibleLanes) {
                        let laneBlocked = false;
                        for (let o of obstacles) {
                            if (o.lane === newLane && Math.abs(o.y - ec.y) < 60) laneBlocked = true;
                        }
                        for (let e2 of enemyCars) {
                            if (e2 !== ec && e2.lane === newLane && Math.abs(e2.y - ec.y) < 60) laneBlocked = true;
                        }
                        if (!laneBlocked) {
                            let dirClass = (newLane < ec.lane) ? 'turn-right' : 'turn-left';
                            ec.el.classList.add(dirClass);
                            setTimeout(() => ec.el.classList.remove(dirClass), 400);
                            ec.lane = newLane;
                            ec.el.style.left = lanes()[ec.lane] + 'px';
                            moved = true;
                            break;
                        }
                    }
                    if (!moved) {
                        // Crash effect: show explosion, fade out, then remove car
                        ec.el.style.transition = 'all 0.5s cubic-bezier(0.3,0.7,0.4,1)';
                        ec.el.style.boxShadow = '0 0 32px 16px #ff0, 0 0 64px 32px #f00, 0 0 80px 40px #fff8';
                        ec.el.style.opacity = '0.2';
                        ec.el.style.transform += ' scale(1.3) rotate(-18deg)';
                        setTimeout(() => { ec.el.remove(); }, 500);
                        enemyCars[idx]._toRemove = true;
                    }
                    break;
                }
            }

            // --- Enemy steals upgrades ---
            for (let upg of upgrades) {
                const enemyRect = ec.el.getBoundingClientRect();
                const upgRect = upg.el.getBoundingClientRect();
                if (rectsOverlap(enemyRect, upgRect)) {
                    // Remove upgrade from track and array
                    upg.el.remove();
                    upgrades = upgrades.filter(u => u !== upg);
                    // Visual feedback: flash enemy car
                    ec.el.style.boxShadow = '0 0 24px 10px #ffd700, 0 0 36px 18px #ffd70077 inset';
                    setTimeout(() => { ec.el.style.boxShadow = ''; }, 600);
                    // Optionally: give enemy a temporary speed boost
                    ec.ai.speed *= 1.5;
                    setTimeout(() => { ec.ai.speed /= 1.5; }, 1200);
                }
            }

            // --- Enemy uses boosts ---
            for (let bst of boosts) {
                const enemyRect = ec.el.getBoundingClientRect();
                const bstRect = bst.el.getBoundingClientRect();
                if (rectsOverlap(enemyRect, bstRect)) {
                    // Remove boost from track and array
                    bst.el.remove();
                    boosts = boosts.filter(b => b !== bst);
                    // Visual feedback: green glow
                    ec.el.style.boxShadow = '0 0 24px 10px #0f7, 0 0 36px 18px #0f7 inset';
                    // Temporarily double enemy speed
                    let oldSpeed = ec.ai.speed;
                    ec.ai.speed = oldSpeed * 2;
                    setTimeout(() => {
                        ec.ai.speed = oldSpeed;
                        ec.el.style.boxShadow = '';
                    }, 1000);
                }
            }

            if (!collided) {
                // 30% chance to attempt a lane change (normal AI)
                if (Math.random() < 0.3) {
                    let possibleLanes = [];
                    if (ec.lane > 0) possibleLanes.push(ec.lane - 1);
                    if (ec.lane < laneCount - 1) possibleLanes.push(ec.lane + 1);
                    if (possibleLanes.length > 0) {
                        let newLane = possibleLanes[Math.floor(Math.random() * possibleLanes.length)];
                        let dirClass = '';
                        if (newLane < ec.lane) dirClass = 'turn-right';
                        if (newLane > ec.lane) dirClass = 'turn-left';
                        if (dirClass) {
                            ec.el.classList.add(dirClass);
                            setTimeout(() => ec.el.classList.remove(dirClass), 400);
                        }
                        ec.lane = newLane;
                        ec.el.style.left = lanes()[ec.lane] + 'px';
                    }
                }
            }
        });
        // Remove enemy cars that spun off the road
        enemyCars = enemyCars.filter(ec => !ec._toRemove);
    }, 700);
    
    // =============================
    //      UPGRADE MENU
    // =============================
    // Show the upgrade menu overlay.
    function showUpgradeMenu() {
        upgradeMenu.classList.add('show');
        upgradePending = true;
        shopOpen = true;
        paused = true;
    }
    // Hide the upgrade menu overlay.
    function hideUpgradeMenu() {
        upgradeMenu.classList.remove('show');
        upgradePending = false;
        shopOpen = false;
        paused = false;
        if (gameRunning) requestAnimationFrame(gameLoop);
    }
// =============================
//      MOVE GAME OBJECTS
// =============================
    // Move all game objects (enemies, obstacles, boosts, upgrades, hearts) and animate the track.
    function moveObjs(){
        // --- Density adjustment based on track height ---
        const referenceHeight = 400;
        const currentHeight = track.offsetHeight || referenceHeight;
        const densityFactor = currentHeight / referenceHeight;
        // To keep density consistent, divide movement by densityFactor

        // Move track lane lines to create illusion of motion
        lineOffset = (lineOffset + carSpeed / densityFactor) % 48;
        // Animate both background layers: dashed center line and side lines
        track.style.backgroundPosition = `0 ${lineOffset}px, 0 0`;
        // Animate yellow lane divider dashed lines by shifting their background position
        document.querySelectorAll('.lane-divider').forEach(divider => {
            // Move the background position to create a moving dashed effect
            divider.style.backgroundPositionY = `${lineOffset}px`;
        });
        // Move enemies
        enemyCars.forEach(ec => {
            ec.y += enemySpeed / densityFactor;
            ec.el.style.top = ec.y + 'px';
        });
        // Remove off-screen enemies and increment score
        enemyCars = enemyCars.filter(ec=>{
            if (ec.y > track.offsetHeight) {
                ec.el.remove();
                score++;
                scoreVal.textContent = score;
                // Increase speed every 5 points
                if (score % 5 === 0 && enemySpeed < 12) enemySpeed += 0.7 * carSpeed;
                // Show upgrade menu every upgradeEvery points
                if (score > 0 && score % upgradeEvery === 0 && score !== lastUpgradeAt) {
                    lastUpgradeAt = score;
                    showUpgradeMenu();
                }
                return false;
            }
            return true;
        });

        // Move obstacles
        obstacles.forEach(obs => {
            obs.y += carSpeed / densityFactor;
            obs.el.style.top = obs.y + 'px';
        });
        obstacles = obstacles.filter(obs=>{
            if (obs.y > track.offsetHeight) {
                obs.el.remove();
                return false;
            }
            return true;
        });

        // Move upgrades
        upgrades.forEach(upg => {
            upg.y += carSpeed / densityFactor;
            upg.el.style.top = upg.y + 'px';
        });
        upgrades = upgrades.filter(upg=>{
            if (upg.y > track.offsetHeight) {
                upg.el.remove();
                return false;
            }
            return true;
        });

        // Move boosts
        boosts.forEach(bst => {
            bst.y += carSpeed / densityFactor;
            bst.el.style.top = bst.y + 'px';
        });
        boosts = boosts.filter(bst=>{
            if (bst.y > track.offsetHeight) {
                bst.el.remove();
                return false;
            }
            return true;
        });
    }
    // =============================
    //      COLLISION DETECTION
    // =============================
    // Check for collisions between the player and other objects.
    function collDetect(){
        const playerRect = playerCar.getBoundingClientRect();
        // Enemy cars
        for (let ec of enemyCars) {
            const enemyRect = ec.el.getBoundingClientRect();
            if (rectsOverlap(playerRect, enemyRect)) {
                if (shield) {
                    ec.el.remove();
                    enemyCars = enemyCars.filter(e=>e!==ec);
                    shield = false;
                    playerCar.classList.remove('shield');
                } else {
                    removeLife();
                    return;
                }
            }
        }
        // Obstacles
        for (let obs of obstacles) {
            const obsRect = obs.el.getBoundingClientRect();
            if (rectsOverlap(playerRect, obsRect)) {
                if (shield) {
                    obs.el.remove();
                    obstacles = obstacles.filter(o=>o!==obs);
                    shield = false;
                    playerCar.classList.remove('shield');
                } else {
                    removeLife();
                    return;
                }
            }
        }
        // Boosts
        for (let bst of boosts) {
            const bstRect = bst.el.getBoundingClientRect();
            if (rectsOverlap(playerRect, bstRect)) {
                bst.el.remove();
                boosts = boosts.filter(b=>b!==bst);
                boostActive = true;
                boostTimeLeft = 120;
                const body = playerCar.querySelector('.body');
                body.style.boxShadow = "0 0 24px 10px #0f7, 0 0 36px 18px #0f7 inset";
                body.style.outline = "4px solid #0f7";
                carSpeed = carSpeed * 2;
            }
        }

// Upgrades
for (let upg of upgrades) {
    const upgRect = upg.el.getBoundingClientRect();
    if (rectsOverlap(playerRect, upgRect)) {
        upg.el.remove();
        upgrades = upgrades.filter(u=>u!==upg);
        coins++;
        updateCoins();
        if (coins > 1) {
            showUpgradeMenu();
        }
        break;
    }
}
        // Heart collision
        heartCollision();
    }

    // =============================
    //      LIFE MANAGEMENT
    // =============================
    // Remove one life and update the display. End the game if no lives remain.
    function removeLife() {
        lives--;
        drawHearts();
        if (lives <= 0) {
            endGame();
        }
    }

    // =============================
    //      GAME LOOP
    // =============================
    // This function runs every animation frame while the game is running.
    // The gameLoop function is called repeatedly using requestAnimationFrame.
    // It updates all game objects, checks for collisions, and spawns new objects.
    function gameLoop() {
        if (!gameRunning || paused || shopOpen) return;
        // Ghost logic
        if (ghostActive) {
            ghostTimer--;
            if (ghostTimer <= 0) {
                ghostActive = false;
                playerCar.style.opacity = '';
                playerCar.style.filter = '';
                playerCar.querySelector('.body').style.boxShadow = '';
            }
        }
        if (boostActive) {
            boostTimeLeft--;
            if (boostTimeLeft <= 0) {
                boostActive = false;
                playerCar.querySelector('.body').style.boxShadow = "";
                playerCar.querySelector('.body').style.outline = "";
                carSpeed = carSpeed / 2;
                enemySpeed = 3 * carSpeed;
            }
        }
        moveObjs();
        moveHearts();
        collDetect();
        spawnObjs();
        attractToCar(boosts);
        attractToCar(upgrades, true);
        drawHearts();
        requestAnimationFrame(gameLoop);
    }
    // =============================
    //      SHOP & PAUSE BUTTONS
    // =============================
    // Open shop button logic
    openShopBtn.addEventListener('click', () => {
        if (!shopOpen && coins > 0) {
            showUpgradeMenu();
        }
    });
    // Pause button logic
    pauseBtn.addEventListener('click', () => {
        paused = !paused;
        if (!paused && !shopOpen) requestAnimationFrame(gameLoop);
    });

    // =============================
    //      COIN USAGE (KEYBOARD)
    // =============================
    document.addEventListener('keydown', e => {
        if (!gameRunning) return;
        if (e.key === 'p' || e.key === 'P') {
            paused = !paused;
            if (!paused && !shopOpen) requestAnimationFrame(gameLoop);
            return;
        }
        if (paused || shopOpen || upgradePending) return;
        if (coins > 0) {
            if (e.key === '1') { carSpeed *= 1.25; enemySpeed = 3 * carSpeed; coins--; updateCoins(); }
            if (e.key === '2') { carSize *= 0.8; setCarSize(carSize); coins--; updateCoins(); }
            if (e.key === '3') { shield = true; playerCar.classList.add('shield'); coins--; updateCoins(); }
            if (e.key === '4') { magnetLeft = true; coins--; updateCoins(); }
            if (e.key === '5') { magnetRight = true; coins--; updateCoins(); }
            if (e.key === '6') { addLife(); coins--; updateCoins(); }
            if (coins === 0 && shopOpen) hideUpgradeMenu();
        }
    });

    // =============================
    //      KEYBOARD CONTROLS
    // =============================
    window.addEventListener('keydown', e=>{
        if (!gameRunning && e.key === 'Enter') resetGame();
        if (e.key === 'ArrowLeft') movePlayer('left');
        if (e.key === 'ArrowRight') movePlayer('right');
        // Accelerate (up arrow)
        if (e.key === 'ArrowUp') {
            acceleratePlayer();
        }
        // Brake (down arrow)
        if (e.key === 'ArrowDown') {
            brakePlayer();
        }
    });
    // =============================
    //      ACCELERATE & BRAKE
    // =============================
    function acceleratePlayer() {
        if (!engineOn || parkingBrake) return;
        if (carSpeed < maxSpeed) {
            carSpeed += 0.3;
            if (carSpeed > maxSpeed) carSpeed = maxSpeed;
            enemySpeed = 3 * carSpeed;
            playerCar.querySelector('.body').style.boxShadow = '0 0 24px 10px #0af, 0 0 36px 18px #0af7 inset';
            setTimeout(() => { playerCar.querySelector('.body').style.boxShadow = ''; }, 200);
        }
    }

    function brakePlayer() {
        if (!engineOn || parkingBrake) return;
        let minSpeed = 0.7;
        if (carSpeed > minSpeed) {
            carSpeed -= 0.3;
            if (carSpeed < minSpeed) carSpeed = minSpeed;
            enemySpeed = 3 * carSpeed;
            playerCar.querySelector('.body').style.boxShadow = '0 0 24px 10px #fa0, 0 0 36px 18px #fa07 inset';
            setTimeout(() => { playerCar.querySelector('.body').style.boxShadow = ''; }, 200);
        }
    }
// =============================
//      ENGINE & PARKING BRAKE BUTTONS
// =============================
const engineBtn = document.getElementById('engine-btn');
const parkBtn = document.getElementById('park-btn');

engineBtn.addEventListener('click', () => {
    engineOn = !engineOn;
    if (!engineOn) {
        engineBtn.textContent = 'Start Engine';
        // Optionally, slow to stop
        carSpeed = 0;
        enemySpeed = 0;
        playerCar.querySelector('.body').style.boxShadow = '0 0 24px 10px #888, 0 0 36px 18px #8887 inset';
    } else {
        engineBtn.textContent = 'Stop Engine';
        carSpeed = 1;
        enemySpeed = 3;
        playerCar.querySelector('.body').style.boxShadow = '';
    }
});

parkBtn.addEventListener('click', () => {
    parkingBrake = !parkingBrake;
    if (parkingBrake) {
        parkBtn.textContent = 'Release Brake';
        carSpeed = 0;
        enemySpeed = 3 * carSpeed;
        playerCar.querySelector('.body').style.boxShadow = '0 0 24px 10px #f44, 0 0 36px 18px #f447 inset';
    } else {
        parkBtn.textContent = 'Parking Brake';
        // Restore carSpeed to minimum if it was 0
        if (carSpeed === 0) carSpeed = 1;
        if (enemySpeed === 0) enemySpeed = 3 * carSpeed;
        playerCar.querySelector('.body').style.boxShadow = '';
    }
});
// Keyboard shortcuts for engine and parking brake
window.addEventListener('keydown', e => {
    if (e.key === 'e' || e.key === 'E') {
        engineBtn.click();
    }
    if (e.key === 'b' || e.key === 'B') {
        parkBtn.click();
    }
});
    // =============================
    //      ACCEL/BRAKE BUTTONS (MOBILE)
    // =============================
    document.getElementById('accel-btn').addEventListener('click', acceleratePlayer);
    document.getElementById('brake-btn').addEventListener('click', brakePlayer);

    // =============================
    //      TOUCH/SWIPE CONTROLS (MOBILE)
    // =============================
    // Allows the player to swipe left/right to move the car on mobile devices.
    let touchStartX = null;
    track.addEventListener('touchstart', e=>{
        if (e.touches.length===1) touchStartX = e.touches[0].clientX;
    });
    track.addEventListener('touchend', e=>{
        if (touchStartX===null) return;
        let dx = (e.changedTouches[0].clientX - touchStartX);
        if (Math.abs(dx) > 40) {
            if (dx > 0) movePlayer('right');
            else movePlayer('left');
        }
        touchStartX = null;
    });

    // =============================
    //      RESPONSIVE: RECALCULATE LANES ON RESIZE
    // =============================
    // When the window is resized, recalculate lane positions and redraw dividers.
    window.addEventListener('resize', ()=>{
        setCarPosition();
        enemyCars.forEach(ec=>{
            ec.el.style.left = lanes()[ec.lane] + 'px';
        });
        obstacles.forEach(obs=>{
            obs.el.style.left = (lanes()[obs.lane] - 20) + 'px';
        });
        boosts.forEach(bst=>{
            bst.el.style.left = (lanes()[bst.lane] - 19) + 'px';
        });
        createLaneDividers();
    });

    // =============================
    //      UPGRADE BUTTON LOGIC
    // =============================
    // Each upgrade button applies a different effect to the player or game.
    upgradeBtns.speed.onclick = ()=>{
        maxSpeed *= 1.25;
        coins = Math.max(0, coins - 1);
        updateCoins();
        if (coins === 0) hideUpgradeMenu();
    };
    upgradeBtns.size.onclick = ()=>{
        carSize *= 0.8;
        setCarSize(carSize);
        coins = Math.max(0, coins - 1);
        updateCoins();
        if (coins === 0) hideUpgradeMenu();
    };
    upgradeBtns.shield.onclick = ()=>{
        shield = true;
        playerCar.classList.add('shield');
        coins = Math.max(0, coins - 1);
        updateCoins();
        if (coins === 0) hideUpgradeMenu();
    };
    upgradeBtns.magnetLeft.onclick = ()=>{
        magnetLeft = true;
        coins = Math.max(0, coins - 1);
        updateCoins();
        if (coins === 0) hideUpgradeMenu();
    };
    upgradeBtns.magnetRight.onclick = ()=>{
        magnetRight = true;
        coins = Math.max(0, coins - 1);
        updateCoins();
        if (coins === 0) hideUpgradeMenu();
    };
    upgradeBtns.heart.onclick = ()=>{
        addLife();
        coins = Math.max(0, coins - 1);
        updateCoins();
        if (coins === 0) hideUpgradeMenu();
    };
    upgradeBtns.close.onclick = ()=>{
        hideUpgradeMenu();
    };

    // =============================
    //      RESET GAME
    // =============================
    // Reset all game variables and state to start a new game.
    // This function is called at the start and when restarting the game.
    // It sets all variables to their initial values and prepares the game for play.
    function resetGame() {
        document.querySelectorAll('.upgrade').forEach(e=>e.remove());
        upgradeSpawnTimer = 350; // adjust as needed
        startTimer();
        playerLane = Math.floor(laneCount / 2); // Start in center lane
        score = 0;
        carSpeed = 1;
        carSize = 1; // should be 1 for normal size
        shield = true;
        boostActive = false;
        upgrades = [];
        boostTimeLeft = 0;
        lastUpgradeAt = 0;
        enemyCars = [];
        enemySpeed = 3;
        enemySpawnTimer = 0;
        obstacleTimer = 60;
        boostTimer = 100;
        obstacles = [];
        boosts = [];
        lives = 3; // Reset lives on game restart
        scoreVal.textContent = score;
        coins = 0;
        updateCoins();
        gameOverScreen.classList.remove('show');
        upgradeMenu.classList.remove('show');
        playerCar.classList.remove('shield');
        makeCarDOM(playerCar); // reset visuals
        setCarSize(carSize);
        setCarPosition();
        document.querySelectorAll('.car.enemy, .obstacle, .boost').forEach(e=>e.remove());
        shopOpen = false;
        paused = false;
        magnetLeft = false;
        magnetRight = false;
        createLaneDividers();
        drawHearts();
        gameRunning = true;
        requestAnimationFrame(gameLoop);
    }

    
    // =============================
    //      START GAME ON PAGE LOAD
    // =============================
    // When the page loads, start a new game.
    document.addEventListener('DOMContentLoaded', () => {
        resetGame();
    });
    
// =============================
//      TIMER LOGIC
// =============================
// These functions keep track of how long the player survives.
let time = 0;
let timerInterval = null;

// Call this function to start the timer when a new game begins.
function startTimer() {
    time = 0;
    timerInterval = setInterval(() => {
        time++;
        document.getElementById('timer').textContent = 'Time: ' + time + 's';
    }, 1000);
}

// Call this function to stop the timer (e.g., when the game ends).
function stopTimer() {
    clearInterval(timerInterval);
}
 // =============================
 //      HEART (LIFE) OVERLAY
 // =============================
 // Draws the heart icons (lives) in the top-left overlay.
    function drawHearts() {
        const overlay = document.getElementById('lives-overlay');
        overlay.innerHTML = '';
        for (let i = 0; i < lives; i++) {
            overlay.innerHTML += `<span class="heart"><svg viewBox='0 0 32 32'><path d='M16 29s-11-7.6-11-15.2C5 7.6 9.6 4 16 10.2 22.4 4 27 7.6 27 13.8 27 21.4 16 29 16 29z' fill='#e33' stroke='#fff' stroke-width='2'/></svg></span>`;
        }
    }
    // =============================
    //      HEART (LIFE) ON TRACK
    // =============================
    // Spawns a heart on the track that the player can collect for an extra life.
    function spawnHeart() {
        const laneIdx = Math.floor(Math.random()*laneCount);
        const heart = document.createElement('div');
        heart.className = 'heart-track';
        heart.style.left = (lanes()[laneIdx] - 16) + 'px';
        heart.style.top = '-32px';
        heart.dataset.lane = laneIdx;
        heart.innerHTML = `<svg viewBox='0 0 32 32'><path d='M16 29s-11-7.6-11-15.2C5 7.6 9.6 4 16 10.2 22.4 4 27 7.6 27 13.8 27 21.4 16 29 16 29z' fill='#e33' stroke='#fff' stroke-width='2'/></svg>`;
        track.appendChild(heart);
        heartsOnTrack.push({el:heart, lane:laneIdx, y:-32});
    }
    let heartsOnTrack = [];
    // Move hearts on track
    // Moves heart objects down the track and removes them if off-screen.
    function moveHearts() {
        heartsOnTrack.forEach(h => {
            h.y += carSpeed;
            h.el.style.top = h.y + 'px';
        });
        heartsOnTrack = heartsOnTrack.filter(h => {
            if (h.y > track.offsetHeight) {
                h.el.remove();
                return false;
            }
            return true;
        });
    }
    // Heart collision
    // Checks if the player collects a heart on the track.
    function heartCollision() {
        const playerRect = playerCar.getBoundingClientRect();
        for (let h of heartsOnTrack) {
            const hRect = h.el.getBoundingClientRect();
            if (rectsOverlap(playerRect, hRect)) {
                h.el.remove();
                heartsOnTrack = heartsOnTrack.filter(x=>x!==h);
                addLife();
                break;
            }
        }
    }

    // Add life function
    // Increases the player's lives by one and redraws the hearts overlay.
    // Call this when the player collects a heart or gets a heart upgrade.
    function addLife() {
        lives++;
        drawHearts();
    }
</script>
</body>
</html>
